# -*- coding: utf-8 -*-
"""sentAnal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HJzdu9KWU64-0o31acRjXCIuwh8Dhl3y
"""

#prepare model fro sentimanetal analysis
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import confusion_matrix,accuracy_score,classification_report,f1_score,recall_score,precision_score
import joblib
import nltk
import re

from nltk.corpus import stopwords
nltk.download('stopwords')
stopwords = set(stopwords.words('english'))
print(stopwords)

df = pd.read_csv('IMDB Dataset.csv')
df.head()

df.shape

df.info()

df["review"].value_counts()

df["sentiment"].value_counts()

#mapping sentiment to some numerical value
df["sentiment"] = df["sentiment"].map({"positive":1,"negative":0})

#clean the text
def clean_text(text):
  text = re.sub(r"[^a-zA-Z]"," ",text).lower()
  #the above line will replace all expressions other than aplhabets to spaces, and to make machine to understand all the letters are converted into lower as machine is case sensitive-
  #machine asumes AS and as as 2 different words
  tokens = text.split()
  tokens= [word for word in tokens if word not in stopwords]
  return " ".join(tokens)

#apply the clean_text function on review
df["cleaned_review"] = df["review"].apply(clean_text)

df["cleaned_review"]

#feature extraction
vectorizer = CountVectorizer(max_features=5000)#countvectorizer will sort all the tokens in aplhabetical order
X = vectorizer.fit_transform(df["cleaned_review"])

y = df["sentiment"]

#divide the dataset into train test split
X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=1)

from operator import mod
#train the model
model = MultinomialNB()#for text classification we generally use NB naive bayes
model.fit(X_train,y_train)

#make the predictions
y_pred = model.predict(X_test)

#calculate the performance matrix
print("confusion matrix:\n",confusion_matrix(y_test,y_pred))
print("accuracy:\n",accuracy_score(y_test,y_pred))
print("classification report: \n",classification_report(y_test,y_pred))

print(recall_score(y_pred,y_test))
print(precision_score(y_pred,y_test))
print(f1_score(y_pred,y_test))

#save the model and the vectorizer
joblib.dump(model,"sentiment_model.pkl")#save the model
joblib.dump(vectorizer,"vectorizer.pkl")#save the vectorizer

print("model and vectorizer saved successfully")